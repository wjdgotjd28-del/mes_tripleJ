import { useState, useEffect, type ChangeEvent } from "react";
import {
  Box, Dialog, DialogTitle, DialogContent, Button, Typography,
  Divider, TextField, FormControl, RadioGroup, FormControlLabel,
  Radio, IconButton, MenuItem, Checkbox, Table, TableBody,
  TableCell, TableContainer, TableHead, TableRow, Paper,
  DialogActions,
} from "@mui/material";
import { Close as CloseIcon, Add as AddIcon } from "@mui/icons-material";
import type { OrderItemImage, OrderItems, RoutingFormData, RoutingFormDataWithProcessNo } from "../../../type";
import { deleteSingleImageAPI, getOrderItemsdtl, updateOrderItems } from "../api/OrderApi";
import { fetchRoutings } from "../../routings/api/RoutingApi";

interface OrderDetailModalProps {
  open: boolean;
  onClose: () => void;
  data: OrderItems | null;
  onSave: () => void;
  routingList?: RoutingFormData[];
}

export default function OrderDetailModal({
  open,
  onClose,
  data,
  onSave,
  routingList = [],
}: OrderDetailModalProps) {
  const [editData, setEditData] = useState<OrderItems | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [selectedRouting, setSelectedRouting] = useState<RoutingFormDataWithProcessNo[]>([]);
  const [allRoutingList, setAllRoutingList] = useState<RoutingFormData[]>(routingList);
  const [backupData, setBackupData] = useState<OrderItems | null>(data);
  const [confirmOpen, setConfirmOpen] = useState(false);
  const [deletedImageIds, setDeletedImageIds] = useState<number[]>([]); // ÏÇ≠Ï†ú ÏòàÏ†ï Ïù¥ÎØ∏ÏßÄ ID Î™©Î°ù

  useEffect(() => {
    if (!data) return;

    if (!data.order_item_id) {
      setEditData(data);
      setBackupData(data);
      setSelectedRouting(
        (data.routing ?? []).map((r, i) => ({
          routing_id: r.routing_id,
          process_code: r.process_code,
          process_name: r.process_name ?? "",
          process_time: r.process_time ?? "",
          note: r.note ?? "",
          process_no: r.process_no ?? i + 1
        }))
      );
      return;
    }

    fetchDetail(data.order_item_id);
  }, [data]);

  useEffect(() => {
    const loadRoutings = async (): Promise<void> => {
      try {
        const data: RoutingFormData[] = await fetchRoutings();
        setAllRoutingList(data);
      } catch (error) {
        console.error("ÎùºÏö∞ÌåÖ Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®", error);
      }
    };
    if (open) loadRoutings();
  }, [open]);

  const fetchDetail = async (id: number): Promise<void> => {
    const res: OrderItems = await getOrderItemsdtl(id);

    // üîπ Î∞±ÏóîÎìú ÏùëÎãµÏùò snake_case ‚Üí camelCase Î≥ÄÌôò + reg_ynÏùÑ isMainÏúºÎ°ú Îß§Ìïë
    const convertedImages: OrderItemImage[] = (res.image ?? []).map(img => ({
      order_item_img_id: img.order_item_img_id,
      order_item_id: img.order_item_id,
      img_url: img.img_url,
      img_ori_name: img.img_ori_name,
      img_name: img.img_name,
      reg_yn: img.reg_yn === "Y" // reg_ynÏùÑ booleanÏúºÎ°ú Î≥ÄÌôò
    }));

    const convertedRouting: RoutingFormDataWithProcessNo[] = (res.routing ?? []).map((r, i) => ({
      routing_id: r.routing_id,
      process_code: r.process_code,
      process_name: r.process_name ?? "",
      process_time: r.process_time ?? "",
      note: r.note ?? "",
      process_no: r.process_no ?? i + 1
    }));

    setEditData({
      ...res,
      image: convertedImages
    });

    setBackupData({
      ...res,
      image: convertedImages
    });

    const selectedIds = new Set<number>((res.routing ?? []).map(r => r.routing_id));
    const initialSelected = convertedRouting.filter(r => selectedIds.has(r.routing_id));
    setSelectedRouting(initialSelected);

    setIsEditing(false);
  };

  const handleChange = (field: keyof OrderItems, value: string | number): void => {
    if (!isEditing) return;
    setEditData(prev => (prev ? { ...prev, [field]: value } : null));
  };

  const handleImageAdd = (e: ChangeEvent<HTMLInputElement>): void => {
    if (!isEditing || !e.target.files) return;
    const newImages: OrderItemImage[] = Array.from(e.target.files).map(file => {
      const timestamp = Date.now();
      const randomStr = Math.random().toString(36).substring(2, 15);
      const ext = file.name.split(".").pop();
      const savedFileName = `${timestamp}_${randomStr}.${ext}`;
      return {
        img_url: URL.createObjectURL(file),
        img_ori_name: file.name,
        img_name: savedFileName,
        file,
        order_item_img_id: undefined,
        reg_yn: false // ÏÉà Ïù¥ÎØ∏ÏßÄÎäî ÎåÄÌëúÍ∞Ä ÏïÑÎãò
      };
    });
    
    setEditData(prev => {
      if (!prev) return prev;
      const updatedImages = [...(prev.image ?? []), ...newImages];
      // ÎåÄÌëú Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïòÎÇòÎèÑ ÏóÜÏúºÎ©¥ Ï≤´ Î≤àÏß∏Î•º ÎåÄÌëúÎ°ú
      if (!updatedImages.some(img => img.reg_yn)) {
        updatedImages[0].reg_yn = true;
      }
      return { ...prev, image: updatedImages };
    });
    e.target.value = "";
  };

  const handleImageDeleteById = async (imgId: number): Promise<void> => {
    if (!isEditing || !editData?.image) return;

    const imgToDelete = editData.image.find(img => img.order_item_img_id === imgId);
    if (!imgToDelete) return;

    // UIÏóêÏÑúÎßå ÏÇ≠Ï†ú
    setEditData(prev => {
      if (!prev?.image) return prev;
      const updated = prev.image.filter(img => img.order_item_img_id !== imgId);

      // ÎåÄÌëú Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
      if (imgToDelete.reg_yn && updated.length > 0 && !updated.some(img => img.reg_yn)) {
        updated[0].reg_yn = true;
      }

      return { ...prev, image: updated };
    });

    // ÏÇ≠Ï†ú ÏòàÏ†ï ID Ï∂îÍ∞Ä
    setDeletedImageIds(prev => {
      if (!prev.includes(imgId)) return [...prev, imgId];
      return prev;
    });
  };

  // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Ïù¥ÎØ∏ÏßÄ(fileÏù¥ ÏûàÎäî) ÏÇ≠Ï†ú
  const handleImageDelete = (img: OrderItemImage, index: number) => {
    if (!isEditing || !editData?.image) return;

    setEditData(prev => {
      if (!prev?.image) return prev;
      const updated = [...prev.image];
      updated.splice(index, 1);
      return { ...prev, image: updated };
    });

    // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ(DBÏóê ÏûàÎäî Í≤ÉÎßå) ÏÇ≠Ï†ú ÏòàÏ†ï Î™©Î°ùÏóê Ï∂îÍ∞Ä
    if (img.order_item_img_id) {
      setDeletedImageIds(prev => {
        const id = img.order_item_img_id;
        return id !== undefined ? [...prev, id] : prev;
      });
    }

    // ÎåÄÌëú Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏÇ≠Ï†úÎêú Í≤ΩÏö∞ Ï≤òÎ¶¨
    const remainingImages = editData.image?.filter((_, i) => i !== index) ?? [];
    if (img.reg_yn && remainingImages.length > 0 && !remainingImages.some(i => i.reg_yn)) {
      remainingImages[0].reg_yn = true;
      setEditData(prev => prev ? { ...prev, image: remainingImages } : prev);
    }

    // blob URL Ìï¥Ï†ú
    if (img.img_url.startsWith("blob:")) URL.revokeObjectURL(img.img_url);
  };

  // ÎåÄÌëú Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù Ìï∏Îì§Îü¨
  const handleSetMainImage = (index: number): void => {
    if (!isEditing) return;
    
    setEditData(prev => {
      if (!prev?.image) return prev;
      const updatedImages = prev.image.map((img, idx) => ({
        ...img,
        reg_yn: idx === index
      }));
      
      return { ...prev, image: updatedImages };
    });
  };

  const handleRoutingToggle = (routing: RoutingFormData | RoutingFormDataWithProcessNo) => {
    if (!isEditing) return;

    setSelectedRouting(prev => {
      const exists = prev.find(r => r.routing_id === routing.routing_id);
      if (exists) {
        const updated = prev.filter(r => r.routing_id !== routing.routing_id)
                            .map((r, idx) => ({ ...r, process_no: idx + 1 }));
        return updated;
      } else {
        const nextNo = prev.length + 1;
        return [...prev, { ...routing, process_no: nextNo }];
      }
    });
  };

  const handleOrderChange = (id: number, newOrder: number): void => {
    if (!isEditing) return;
    if (newOrder < 1) newOrder = 1;
    setSelectedRouting(prev => prev.map(r => r.routing_id === id ? { ...r, process_no: newOrder } : r));
  };

  const handleSubmit = async (): Promise<void> => {
    if (!editData) return;

    if (!editData.company_name || !editData.item_code || !editData.item_name) {
      alert("ÌïÑÏàò Í∞íÏùÑ Î™®Îëê ÏûÖÎ†•ÌïòÏÑ∏Ïöî.");
      return;
    }

    const formData = new FormData();

    const itemData = {
      company_name: editData.company_name,
      item_name: editData.item_name,
      item_code: editData.item_code,
      category: editData.category,
      color: editData.color ?? "",
      unit_price: editData.unit_price,
      paint_type: editData.paint_type,
      note: editData.note ?? "",
      use_yn: editData.use_yn,
      status: editData.status,
      // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄÏùò reg_yn Ï†ïÎ≥¥Î•º Ìè¨Ìï®
      image: editData.image?.filter(img => img.order_item_img_id).map(img => ({
        order_item_img_id: img.order_item_img_id,
        reg_yn: img.reg_yn ? "Y" : "N"
      }))
    };
    formData.append("orderItem", new Blob([JSON.stringify(itemData)], { type: "application/json" }));

    if (selectedRouting.length > 0) {
      const routingData = selectedRouting
        .sort((a, b) => a.process_no - b.process_no)
        .map((r, i) => ({
          routing_id: r.routing_id,
          process_no: i + 1,
        }));
      formData.append("routing", new Blob([JSON.stringify(routingData)], { type: "application/json" }));
    }

    // ÏÉàÎ°ú Ï∂îÍ∞ÄÌïú Ïù¥ÎØ∏ÏßÄ ÌååÏùº Ï†ÑÏÜ°
    const newImages = editData.image?.filter(img => img.file instanceof File) ?? [];
    newImages.forEach(img => {
      if (img.file instanceof File) formData.append("images", img.file);
    });

    // ÏÉà Ïù¥ÎØ∏ÏßÄÏùò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ (ÎåÄÌëú Ïó¨Î∂Ä Ìè¨Ìï®)
    if (newImages.length > 0) {
      const imageMetaData = newImages.map(img => ({
        img_ori_name: img.img_ori_name,
        img_name: img.img_name,
        reg_yn: img.reg_yn ? "Y" : "N"
      }));
      formData.append("imageMeta", new Blob([JSON.stringify(imageMetaData)], { type: "application/json" }));
    }

    try {
      // 1. Î®ºÏ†Ä ÏÇ≠Ï†ú ÏòàÏ†ï Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
      for (const id of deletedImageIds) {
        try {
          await deleteSingleImageAPI(id);
        } catch (err) {
          console.error("Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú Ïã§Ìå®", err);
        }
      }
      setDeletedImageIds([]);
      // 2. ÏàòÏ†ï ÎÇ¥Ïö© ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ°
      await updateOrderItems(editData.order_item_id, formData);
      
      // 3. Ï†ÄÏû• ÌõÑ Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Î∂àÎü¨Ïò§Í∏∞
      await fetchDetail(editData.order_item_id);
      
      setIsEditing(false);
      onSave();
    } catch (error) {
      console.error(error);
      alert("Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
    }
  };

  const toggleEditMode = (): void => setIsEditing(prev => !prev);

  const handleCancel = (): void => {
    if (!isEditing) {
      onClose();
      return;
    }

    const isChanged = JSON.stringify(editData) !== JSON.stringify(backupData);
    if (isChanged) {
      setConfirmOpen(true);
    } else {
      setIsEditing(false);
    }
  };

  const confirmCancel = (): void => {
    if (backupData) {
      setEditData({ ...backupData });
    }
    setIsEditing(false);
    setConfirmOpen(false);
  };

  const cancelDialogClose = (): void => {
    setConfirmOpen(false);
  };

  const handleClose = (): void => {
    handleCancel();
  };

  const sortedSelectedRouting = [...selectedRouting].sort((a, b) => a.process_no - b.process_no);

  if (!editData) return null;

  return (
    <>
      <Dialog open={open} onClose={handleClose} maxWidth="lg" fullWidth>
        <DialogTitle sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <Typography variant="h6" component="span">ÌíàÎ™© ÏÉÅÏÑ∏ Ï†ïÎ≥¥</Typography>
        </DialogTitle>

        <DialogContent dividers>
          {/* --- Í∏∞Î≥∏/ÏÉÅÏÑ∏ Ï†ïÎ≥¥ --- */}
          <Box sx={{ display: "flex", gap: 4, mb: 3 }}>
            {/* Í∏∞Î≥∏Ï†ïÎ≥¥ */}
            <Box sx={{ flex: 1 }}>
              <Typography variant="subtitle2" color="primary" gutterBottom>Í∏∞Î≥∏Ï†ïÎ≥¥</Typography>
              <Divider sx={{ mb: 2 }} />
              <Box sx={{ display: "grid", gridTemplateColumns: "130px 1fr", gap: 2 }}>
                <Typography color="text.secondary" alignSelf="center">ÏóÖÏ≤¥Î™Ö *</Typography>
                <TextField value={editData.company_name} onChange={e=>handleChange("company_name", e.target.value)} size="small" fullWidth InputProps={{ readOnly: !isEditing }} />
                <Typography color="text.secondary" alignSelf="center">ÌíàÎ™©Î≤àÌò∏ *</Typography>
                <TextField value={editData.item_code} onChange={e=>handleChange("item_code", e.target.value)} size="small" fullWidth InputProps={{ readOnly: !isEditing }} />
                <Typography color="text.secondary" alignSelf="center">ÌíàÎ™©Î™Ö *</Typography>
                <TextField value={editData.item_name} onChange={e=>handleChange("item_name", e.target.value)} size="small" fullWidth InputProps={{ readOnly: !isEditing }} />
                <Typography color="text.secondary" alignSelf="center">Î∂ÑÎ•ò *</Typography>
                <TextField select value={editData.category ?? "GENERAL"} onChange={e=>handleChange("category", e.target.value)} size="small" fullWidth disabled={!isEditing}>
                  <MenuItem value="GENERAL">ÏùºÎ∞ò</MenuItem>
                  <MenuItem value="DEFENSE">Î∞©ÏÇ∞</MenuItem>
                  <MenuItem value="AUTOMOTIVE">ÏûêÎèôÏ∞®</MenuItem>
                  <MenuItem value="SHIPBUILDING">Ï°∞ÏÑ†</MenuItem>
                </TextField>
              </Box>
            </Box>

            {/* ÏÉÅÏÑ∏Ï†ïÎ≥¥ */}
            <Box sx={{ flex: 1 }}>
              <Typography variant="subtitle2" color="primary" gutterBottom>ÏÉÅÏÑ∏Ï†ïÎ≥¥</Typography>
              <Divider sx={{ mb: 2 }} />
              <Box sx={{ display: "grid", gridTemplateColumns: "130px 1fr", gap: 2 }}>
                <Typography color="text.secondary" alignSelf="center">ÏÉâÏÉÅ *</Typography>
                <TextField value={editData.color ?? ""} onChange={e=>handleChange("color", e.target.value)} size="small" fullWidth InputProps={{ readOnly: !isEditing }} />

                <Typography color="text.secondary" alignSelf="center">Îã®Í∞Ä *</Typography>
                <TextField
                  type="text"
                  value={editData.unit_price}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (/^\d*$/.test(val)) {
                      handleChange("unit_price", val === "" ? "" : parseInt(val, 10));
                    }
                  }}
                  onKeyDown={(e) => {
                    if (["e", "E", "+", "-", "."].includes(e.key)) {
                      e.preventDefault();
                    }
                  }}
                  size="small"
                  fullWidth
                  inputProps={{ inputMode: "numeric", min: 1 }}
                  error={editData.unit_price !== "" && Number(editData.unit_price) <= 0}
                  helperText={
                    editData.unit_price !== "" && Number(editData.unit_price) <= 0
                      ? "Îã®Í∞ÄÎäî 0Î≥¥Îã§ Ïª§Ïïº Ìï©ÎãàÎã§."
                      : ""
                  }
                  InputProps={{ readOnly: !isEditing }}
                />
                <Typography color="text.secondary" alignSelf="center">ÎèÑÏû•Î∞©Ïãù *</Typography>
                <FormControl>
                  <RadioGroup row value={editData.paint_type ?? "LIQUID"} onChange={e=>handleChange("paint_type", e.target.value)}>
                    <FormControlLabel value="LIQUID" control={<Radio />} label="Ïï°Ï≤¥" disabled={!isEditing}/>
                    <FormControlLabel value="POWDER" control={<Radio />} label="Î∂ÑÏ≤¥" disabled={!isEditing}/>
                  </RadioGroup>
                </FormControl>

                <Typography color="text.secondary" alignSelf="center">ÏÇ¨Ïö©Ïó¨Î∂Ä *</Typography>
                <FormControl>
                  <RadioGroup row value={editData.use_yn ?? "Y"} onChange={e=>handleChange("use_yn", e.target.value)}>
                    <FormControlLabel value="Y" control={<Radio />} label="Y" disabled={!isEditing}/>
                    <FormControlLabel value="N" control={<Radio />} label="N" disabled={!isEditing}/>
                  </RadioGroup>
                </FormControl>
              </Box>
            </Box>
          </Box>

          {/* --- Ï†ÑÏ≤¥ ÎùºÏö∞ÌåÖ Ï†ïÎ≥¥ (ÏàòÏ†ï Î™®ÎìúÏóêÏÑúÎßå) --- */}
          {isEditing && (
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle2" color="primary" gutterBottom>ÎùºÏö∞ÌåÖ Ï†ïÎ≥¥</Typography>
              <Divider sx={{ mb: 2 }} />

              {allRoutingList.length === 0 ? (
                <Typography variant="body2" color="text.secondary" textAlign="center" sx={{ p: 2, backgroundColor: "#f5f5f5", borderRadius: 1 }}>
                  Îì±Î°ùÎêú ÎùºÏö∞ÌåÖ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§. ÎùºÏö∞ÌåÖ ÎßàÏä§ÌÑ∞Î•º Î®ºÏ†Ä Îì±Î°ùÌï¥Ï£ºÏÑ∏Ïöî.
                </Typography>
              ) : (
                <TableContainer component={Paper} sx={{ maxHeight: 280, mb: 3 }}>
                  <Table stickyHeader size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell padding="checkbox">
                          <Checkbox
                            indeterminate={selectedRouting.length > 0 && selectedRouting.length < allRoutingList.length}
                            checked={selectedRouting.length === allRoutingList.length && allRoutingList.length > 0}
                            onChange={(e) => {
                              if (e.target.checked) setSelectedRouting(allRoutingList.map((r, i) => ({ ...r, process_no: i + 1 })));
                              else setSelectedRouting([]);
                            }}
                            disabled={!isEditing}
                          />
                        </TableCell>
                        <TableCell>Î≤àÌò∏</TableCell>
                        <TableCell>Í≥µÏ†ïÏΩîÎìú</TableCell>
                        <TableCell>Í≥µÏ†ïÎ™Ö</TableCell>
                        <TableCell>Í≥µÏ†ïÏãúÍ∞Ñ</TableCell>
                        <TableCell>ÎπÑÍ≥†</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {allRoutingList.map((r, idx) => {
                        const checked = selectedRouting.some((sr) => sr.routing_id === r.routing_id);
                        return (
                          <TableRow key={r.routing_id} hover>
                            <TableCell padding="checkbox">
                              <Checkbox checked={checked} onChange={() => handleRoutingToggle(r)} disabled={!isEditing} />
                            </TableCell>
                            <TableCell>{idx + 1}</TableCell>
                            <TableCell>{r.process_code}</TableCell>
                            <TableCell>{r.process_name}</TableCell>
                            <TableCell>{r.process_time}</TableCell>
                            <TableCell>{r.note || "-"}</TableCell>
                          </TableRow>
                        );
                      })}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
            </Box>
          )}

          {/* --- ÏÑ†ÌÉù ÎùºÏö∞ÌåÖ (Ìï≠ÏÉÅ Î≥¥Ïó¨Ï§å) --- */}
          <Box>
            <Typography variant="subtitle2" color="primary" gutterBottom>ÏÑ†ÌÉù ÎùºÏö∞ÌåÖ</Typography>
            <Divider sx={{ mb: 2 }} />
            {sortedSelectedRouting.length === 0 ? (
              <Typography variant="body2" color="text.secondary" textAlign="center" sx={{ p: 2 }}>
                ÏÑ†ÌÉùÎêú ÎùºÏö∞ÌåÖ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.
              </Typography>
            ) : (
              <TableContainer component={Paper} sx={{ mb: 3 }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell>ÏàúÏÑú</TableCell>
                      <TableCell>Í≥µÏ†ïÏΩîÎìú</TableCell>
                      <TableCell>Í≥µÏ†ïÎ™Ö</TableCell>
                      <TableCell>Í≥µÏ†ïÏãúÍ∞Ñ</TableCell>
                      <TableCell>ÎπÑÍ≥†</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {sortedSelectedRouting.map((r) => (
                      <TableRow key={r.routing_id}>
                        <TableCell>
                          <TextField
                            type="number"
                            value={r.process_no}
                            size="small"
                            inputProps={{ min: 1, style: { width: 50 } }}
                            disabled={!isEditing}
                            onChange={(e) => {
                              const val = parseInt(e.target.value, 10);
                              if (!isNaN(val) && val > 0) handleOrderChange(r.routing_id, val);
                            }}
                          />
                        </TableCell>
                        <TableCell>{r.process_code}</TableCell>
                        <TableCell>{r.process_name}</TableCell>
                        <TableCell>{r.process_time}</TableCell>
                        <TableCell>{r.note}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            )}
          </Box>

          {/* --- Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú --- */}
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" color="primary" gutterBottom>Ï†úÌíà Ïù¥ÎØ∏ÏßÄ</Typography>
            <Divider sx={{ mb: 2 }} />
            
            {/* Ïù¥ÎØ∏ÏßÄ Î∞ïÏä§: Í∞ÄÎ°ú Ï†ïÎ†¨ */}
            <Box sx={{ display: "flex", flexWrap: "wrap", gap: 2 }}>
              {editData.image?.map((img, idx) => (
                <Box
                  key={img.order_item_img_id ?? `new-${idx}`}
                  sx={{
                    position: "relative",
                    width: 140,
                    height: 140,
                    border: img.reg_yn ? "2px solid #1976d2" : "1px solid #ddd",
                    borderRadius: 1,
                    overflow: "hidden"
                  }}
                >
                  <img
                    src={img.img_url}
                    alt={img.img_ori_name}
                    style={{
                      width: "100%",
                      height: "100%",
                      objectFit: "cover"
                    }}
                  />
                  
                  {/* ÏÇ≠Ï†ú Î≤ÑÌäº */}
                  {isEditing && (
                    <IconButton
                      size="small"
                      sx={{ position: "absolute", top: 4, right: 4, backgroundColor: "rgba(255,255,255,0.8)" }}
                      onClick={() => {
                        // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
                        if (!img.order_item_img_id) {
                          handleImageDelete(img, idx); // Ïó¨Í∏∞ÏÑú Ìò∏Ï∂ú
                        } else {
                          handleImageDeleteById(img.order_item_img_id);
                        }
                      }}
                    >
                      <CloseIcon fontSize="small" />
                    </IconButton>
                  )}

                  {/* ÎåÄÌëú Ïù¥ÎØ∏ÏßÄ Ï≤¥ÌÅ¨Î∞ïÏä§ (ÏàòÏ†ï Î™®ÎìúÏóêÏÑúÎßå) */}
                  {isEditing && (
                    <Checkbox
                      checked={img.reg_yn === true || img.reg_yn === "Y"}
                      onChange={() => handleSetMainImage(idx)}
                      sx={{ 
                        position: "absolute", 
                        top: 4, 
                        left: 4, 
                        backgroundColor: "rgba(255,255,255,0.8)",
                        padding: "4px"
                      }}
                    />
                  )}

                  {/* ÎåÄÌëú ÌëúÏãú (Ï°∞Ìöå Î™®ÎìúÏóêÏÑúÎßå) */}
                  {!isEditing && img.reg_yn && (
                    <Box
                      sx={{
                        position: "absolute",
                        top: 4,
                        left: 4,
                        backgroundColor: "#1976d2",
                        color: "white",
                        px: 1,
                        py: 0.5,
                        borderRadius: 1,
                        fontSize: "0.75rem",
                        fontWeight: "bold"
                      }}
                    >
                      ÎåÄÌëú
                    </Box>
                  )}

                  {/* ÌååÏùºÎ™Ö ÌëúÏãú */}
                  <Box
                    sx={{
                      position: "absolute",
                      bottom: 0,
                      left: 0,
                      right: 0,
                      backgroundColor: "rgba(0,0,0,0.7)",
                      color: "white",
                      p: 0.5
                    }}
                  >
                    <Typography
                      variant="caption"
                      sx={{ 
                        fontSize: "0.65rem", 
                        overflow: "hidden", 
                        textOverflow: "ellipsis", 
                        whiteSpace: "nowrap",
                        display: "block"
                      }}
                    >
                      ÏõêÎ≥∏: {img.img_ori_name}
                    </Typography>
                    <Typography
                      variant="caption"
                      sx={{ 
                        fontSize: "0.6rem", 
                        color: "#aaa", 
                        overflow: "hidden", 
                        textOverflow: "ellipsis", 
                        whiteSpace: "nowrap",
                        display: "block"
                      }}
                    >
                      Ï†ÄÏû•Î™Ö: {img.img_name}
                    </Typography>
                  </Box>
                </Box>
              ))}
              
              {/* Ïù¥ÎØ∏ÏßÄ Ï∂îÍ∞Ä Î≤ÑÌäº */}
              {isEditing && (
                <Button 
                  component="label" 
                  size="small" 
                  startIcon={<AddIcon />}
                  sx={{ 
                    width: 140, 
                    height: 140, 
                    border: "1px dashed #ccc",
                    display: "flex",
                    flexDirection: "column"
                  }}
                >
                  Ïù¥ÎØ∏ÏßÄ Ï∂îÍ∞Ä
                  <input type="file" hidden multiple accept="image/*" onChange={handleImageAdd} />
                </Button>
              )}
            </Box>
          </Box>

          {/* ÌïòÎã® Î≤ÑÌäº */}
          <Box sx={{ display: "flex", justifyContent: "flex-end", mt: "auto" }}>
            {!isEditing ? (
              <>
                <Button
                  variant="outlined"
                  size="small"
                  color="error"
                  onClick={handleClose}
                >
                  Îã´Í∏∞
                </Button>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={toggleEditMode}
                  sx={{ ml: 1 }}
                >
                  ÏàòÏ†ï
                </Button>
              </>
            ) : (
              <>
                <Button
                  variant="outlined"
                  size="small"
                  color="error"
                  onClick={handleCancel}
                >
                  Ï∑®ÏÜå
                </Button>
                <Button
                  variant="outlined"
                  size="small"
                  color="success"
                  onClick={handleSubmit}
                  sx={{ ml: 1 }}
                >
                  Ï†ÄÏû•
                </Button>
              </>
            )}
          </Box>          
        </DialogContent>
      </Dialog>

      {/* ‚úÖ Ìé∏Ïßë Ï∑®ÏÜå ÌôïÏù∏ Îã§Ïù¥ÏñºÎ°úÍ∑∏ */}
      <Dialog open={confirmOpen} onClose={cancelDialogClose}>
        <DialogTitle>Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥† ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?</DialogTitle>
        <DialogContent>Î≥ÄÍ≤ΩÎêú ÎÇ¥Ïö©ÏùÄ Ï†ÄÏû•ÎêòÏßÄ ÏïäÏäµÎãàÎã§.</DialogContent>
        <DialogActions>
          <Button color="error" onClick={confirmCancel}>
            Ïòà
          </Button>
          <Button onClick={cancelDialogClose}>ÏïÑÎãàÏò§</Button>
        </DialogActions>
      </Dialog>
    </>
  );
}